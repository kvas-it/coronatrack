<html lang="en">
  <head>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="data.js"></script>
    <style type="text/css">
body {
  font-family: Helvetica, Arial, Sans-serif;
  font-size: 12px;
  padding: 20px 100px;
}

.graph {}

.swatches, .chart-options {
  line-height: 1.5;
  margin-bottom: 10px;
}

.chart-options {
  float: left;
  margin-right: 20px;
}

.swatch {
  padding: 2px;
  white-space: nowrap;
  border-radius: 3px;
}

.tick line {
  stroke: #ddd;
}
    </style>
  </head>
  <body>
    <h1>COVID-19 total cases, new cases and change in new cases</h1>

    <div class="graph" id="cases"></div>

    <h2>More information</h2>

    <ul>
      <li><a href="https://www.who.int/emergencies/diseases/novel-coronavirus-2019">WHO information page</a></li>
      <li><a href="https://www.ecdc.europa.eu/en/novel-coronavirus-china">Information by European Centre for Disease Prevention and Control</a></li>
      <li><a href="https://www.cdc.gov/coronavirus/2019-ncov/">Information by US CDC</a></li>
      <li><a href="https://gisanddata.maps.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6">Map and tracker by John Hopkins CSSE</a> (data source for this website)</li>
      <li><a href="https://thewuhanvirus.com/">Map and tracker by thebaselab</a></li>
      <li><a href="https://bnonews.com/index.php/2020/02/the-latest-coronavirus-cases/">BNO News feed</a></li>
      <li><a href="https://www.worldometers.info/coronavirus/">Worldometer stats and news feed</a></li>
    </ul>

    <script type="text/javascript">
const margin = {top: 10, right: 70, bottom: 30, left: 30};
const height = 900;
const heights = {cases: 500, cases_d: 200, cases_dd: 200};
const width = 1200;
const periods = {
  "All": 10000,
  "1 month": 30,
  "2 weeks": 14,
  "1 week": 7
};
const yesNo = {
  "no": false,
  "yes": true,
}

function makeData(records, regions, regionsToSkip, period, smoothing) {
  var data = [];
  var maxCount = periods[period[0]];
  var smooth = yesNo[smoothing[0]];

  records = records.slice(-maxCount, records.length);
  for (let i = 0; i < records.length; i++) {
    var r = {date: new Date(records[i][0])};
    for (let j = 0; j < regions.length; j++) {
      if (regionsToSkip.includes(regions[j])) continue;
      if (smooth) {
        var current, prev, next;
        current = records[i][j + 1];
        if (i == 0) {
          next = records[i + 1][j + 1];
          prev = 2 * current - next;  // linear interp from first 2 points
        } else if (i == records.length - 1) {
          prev = records[i - 1][j + 1];
          next = 2 * current - prev;  // linear interp from last 2 points
        } else {
          prev = records[i - 1][j + 1];
          next = records[i + 1][j + 1];
        }
        r[regions[j]] = (prev + 2 * current + next) / 4;
      } else {
        r[regions[j]] = records[i][j + 1];
      }
    }
    data.push(r);
  }

  data.columns = ["date"]
    .concat(regions.filter(r => !regionsToSkip.includes(r)));

  return data;
}

function makeChart(data, params_) {
  let params = params_ || {};
  let height = params.height || 600;
  let width = params.width || 1200;
  let stacked = params.stacked || false;
  let series;

  if (stacked) {
    let stack = d3.stack()
      .keys(regions)
      .order(d3.stackOrderAscending)
    series = stack(data);
  } else {
    series = regions.map(r => {
      let values = data.map(c => ({v: c[r], d: c.date}));
      values.key = r;
      return values;
    });
  }

  let chart = d3.create("svg")
    .attr("viewBox", [0, 0, width, height]);

  let x = d3.scaleUtc()
      .domain(d3.extent(data, d => d.date))
      .range([margin.left, width - margin.right]);
  let xTickSize = height - margin.top - margin.bottom;
  let xAxis = g => g
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).tickSize(-xTickSize).tickSizeOuter(-xTickSize));

  let y = d3.scaleLinear()
    .domain([0, d3.max(series, d => d3.max(d, d => d[1] || d.v))]).nice()
    .range([height - margin.bottom, margin.top]);
  let yTickSize = width - margin.left - margin.right;
  let yAxis = g => g
    .attr("transform", `translate(${width - margin.right},0)`)
    .call(d3.axisRight(y).tickSize(-yTickSize).tickSizeOuter(-yTickSize))
    .call(g => g.select(".domain").remove())
    .call(g => g.select(".tick:last-of-type text").clone()
      .attr("x", 3)
      .attr("text-anchor", "start")
      .attr("font-weight", "bold")
      .text(data.y));

  chart.append("g").call(xAxis);
  chart.append("g").call(yAxis);

  if (stacked) {
    let area = d3.area()
      .x(d => x(d.data.date))
      .y0(d => y(d[0]))
      .y1(d => y(d[1]));

    chart.append("g")
      .selectAll("path")
      .data(series)
      .join("path")
        .attr("fill", ({key}) => color(key))
        .attr("stroke-width", 0.5)
        .attr("stroke", ({key}) => d3.hsl(color(key)).darker())
        .attr("d", area)
      .append("title")
        .text(({key}) => key);
  } else {
    let line = d3.line()
      .x(d => x(d.d))
      .y(d => y(d.v));

    chart.append("g")
      .selectAll("path")
      .data(series)
      .join("path")
        .attr("fill", "none")
        .attr("stroke-width", 1.5)
        .attr("stroke", ({key}) => color(key))
        .attr("d", line)
      .append("title")
        .text(({key}) => key);
  }

  return chart.node();
}

function makeKey(regions, excluded) {
  let key = d3.create("div")
    .classed("swatches", true);

  key.append("span").text("Regions: ");

  key.append("span")
    .text(excluded.length > 10 ? "All" : "None")
    .classed("swatch", true)
    .style("background-color", excluded.length > 10 ? "white" : "grey")
    .on("click", function () {
      let swatch = d3.select(this);
      let active = swatch.style("background-color") == "grey";
      excluded.splice(0, excluded.length);
      if (active) {
        regions.map(r => {excluded.push(r);});
      }
      updateGraph();
    });
  key.append("span").text(" ");

  regions.map(region => {
    key.append("span")
      .text(region)
      .classed("swatch", true)
      .style("background-color", excluded.includes(region) ? "white"
                                                           : color(region))
      .on("click", function () {
        let swatch = d3.select(this);
        let active = !excluded.includes(region);
        if (active) {
          excluded.push(region);
        } else {
          excluded.splice(excluded.indexOf(region), 1);
        }
        updateGraph();
      });
    key.append("span").text(" ");
  });

  return key.node();
}

function chartOptions(name, options, current) {
  let ts = d3.create("div").classed("chart-options", true);

  ts.append("span").text(name + ": ");

  for (let o in options) {
    let isOn = current.includes(o);
    ts.append("span")
      .text(o)
      .classed("swatch", true)
      .style("background-color", isOn ? "#ccccff" : "white")
      .on("click", function () {
        let swatch = d3.select(this);
        current[0] = o;
        updateGraph();
      });
    ts.append("span").text(" ");
  }

  return ts.node();
}

let regions = allData.regions;
let excludedRegions = [];
let colorScheme = [];
let period = ["All"];  // All | Last week | 2 weeks: array to modify in place.
let smoothing = ["no"];
let stacked = ["yes"];

for (let i = 0; i < regions.length; i++) {
  regions[i] += ': ' + allData.cases[allData.cases.length - 1][i + 1];
  colorScheme.push(d3.interpolateSinebow(i / regions.length));
}

let color = d3.scaleOrdinal()
  .domain(regions)
  .range(colorScheme);

function updateGraph() {
  let cases = makeData(allData.cases, regions, excludedRegions, period, smoothing);
  let cases_d = makeData(allData.cases_d, regions, excludedRegions, period, smoothing);
  let cases_dd = makeData(allData.cases_dd, regions, excludedRegions, period, smoothing);

  d3.select("#cases").html("");
  d3.select("#cases").append(() => makeKey(regions, excludedRegions));
  d3.select("#cases").append(() => chartOptions("Period", periods, period));
  d3.select("#cases").append(() => chartOptions("Smoothing", yesNo, smoothing));
  d3.select("#cases").append(() => chartOptions("Stacked", yesNo, stacked));

  d3.select("#cases").append(() => makeChart(cases, {stacked: yesNo[stacked[0]]}));
  d3.select("#cases").append(() => makeChart(cases_d, {stacked: yesNo[stacked[0]]}));
}

updateGraph();
    </script>
  </body>
</html>
