<html lang="en">
  <head>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="data.js"></script>
    <style type="text/css">
body {
  font-family: Helvetica, Arial, Sans-serif;
  font-size: 12px;
  padding: 20px 100px;
}

.regions, .chart-options {
  line-height: 1.5;
  margin-bottom: 10px;
}

.chart-options {
  float: left;
  margin-right: 20px;
}

.swatch {
  cursor: pointer;
  padding: 2px;
  white-space: nowrap;
  border-radius: 3px;
}

.tick line {
  stroke: #ddd;
}
    </style>
  </head>
  <body>
    <h1>COVID-19 total cases, new cases and change in new cases</h1>

    <div>
      <div id="options"></div>
      <div id="cases"></div>
    </div>

    <h2>More information</h2>

    <ul>
      <li><a href="https://www.who.int/emergencies/diseases/novel-coronavirus-2019">WHO information page</a></li>
      <li><a href="https://www.ecdc.europa.eu/en/novel-coronavirus-china">Information by European Centre for Disease Prevention and Control</a></li>
      <li><a href="https://www.cdc.gov/coronavirus/2019-ncov/">Information by US CDC</a></li>
      <li><a href="https://gisanddata.maps.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6">Map and tracker by John Hopkins CSSE</a> (data source for this website)</li>
      <li><a href="https://thewuhanvirus.com/">Map and tracker by thebaselab</a></li>
      <li><a href="https://bnonews.com/index.php/2020/02/the-latest-coronavirus-cases/">BNO News feed</a></li>
      <li><a href="https://www.worldometers.info/coronavirus/">Worldometer stats and news feed</a></li>
    </ul>

    <script type="text/javascript">
const margin = {top: 10, right: 70, bottom: 30, left: 20};

const stdHeight = 600;
const stdWidth = 1200;

const seriesOptions = {
  "New cases": allData.cases,
  "Deaths": allData.deaths,
  "Recovered": allData.recovered,
  "Active cases": allData.active,
};

const periods = {
  "All": 10000,
  "1 month": 30,
  "2 weeks": 14,
  "1 week": 7,
};

const yesNo = {
  "no": false,
  "yes": true,
};

const smoothingLevels = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "5": 5,
  "8": 8,
};

const transmissionCurve = [
  0,    // 1st day after becoming infected not infectious yet,
  0,    // 2nd day
  0.05, // 3rd day, start asymptomatic transmission
  0.15, // 4th day
  0.25, // 5th day, maybe symptoms
  0.2,  // 6th day, decay from carantine, hospital, etc.
  0.15, // 7
  0.1,  // 8
  0.05, // 9
  0.05  // 10
];

function impliedRTransform(getValue, i, length) {
  if (i < transmissionCurve.length) {
    return 0;
  } else {
    let sourceN = transmissionCurve
      .map((v, idx) => getValue(i - 1 - idx) * v)
      .reduce((a, b) => a + b);
    let curN = getValue(i);
    if (sourceN <= 0) return 0;
    if (curN <= 0) return 0;
    return curN / sourceN;
  }
}

function smoothTransform(getValue, i, length) {
  if (i == 0 || i == length - 1) {
    return getValue(i);
  } else {
    return (getValue(i - 1) + getValue(i + 1) + getValue(i)) / 3;
  }
}

function rateTransform(getValue, i, length) {
  if (i == 0) {
    return 0;
  } else {
    return getValue(i) - getValue(i - 1);
  }
}

function applyTransform(transform, records) {
  let result = [];
  for (let i = 0; i < records.length; i++) {
    let r = [records[i][0]];
    for (let j = 1; j < records[i].length; j++) {
      r.push(transform(i_ => records[i_][j], i, records.length));
    }
    result.push(r)
  }
  return result;
}

function prepareData(records, regions, regionsToSkip, period, smoothing) {
  let data = [];
  let maxCount = periods[period[0]];

  records = records.slice(-maxCount, records.length);

  let smoothingLevel = smoothingLevels[smoothing[0]];
  for (let i = 0; i < smoothingLevel; i++) {
    records = applyTransform(smoothTransform, records);
  }

  for (let i = 0; i < records.length; i++) {
    var r = {date: new Date(records[i][0])};
    for (let j = 0; j < regions.length; j++) {
      if (regionsToSkip.includes(regions[j])) continue;
      r[regions[j]] = records[i][j + 1];
    }
    data.push(r);
  }

  data.columns = ["date"]
    .concat(regions.filter(r => !regionsToSkip.includes(r)));

  return data;
}

function makeChart(data, params_) {
  let params = params_ || {};
  let height = params.height || stdHeight;
  let width = params.width || stdWidth;
  let stacked = params.stacked || false;
  let title = params.title || '?';
  let titleSlug = title.toLowerCase().replace(/\s/g, "-");
  let series;

  if (stacked) {
    let stack = d3.stack()
      .keys(regions)
      .order(d3.stackOrderAscending)
    series = stack(data);
  } else {
    series = regions.map(r => {
      let values = data.map(c => ({v: c[r], d: c.date}));
      values.key = r;
      return values;
    });
  }

  let chart = d3.create("svg")
    .attr("viewBox", [0, 0, width, height]);

  let x = d3.scaleUtc()
      .domain(d3.extent(data, d => d.date))
      .range([margin.left, width - margin.right]);
  let xTickSize = height - margin.top - margin.bottom;
  let xAxis = g => g
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).tickSize(-xTickSize).tickSizeOuter(-xTickSize));

  let minValue = params_.minValue || d3.min(series, d => d3.min(d, d => d[1] || d.v));
  let maxValue = params_.maxValue || d3.max(series, d => d3.max(d, d => d[1] || d.v));
  let y = d3.scaleLinear()
    .domain([minValue, maxValue]).nice()
    .range([height - margin.bottom, margin.top]);
  let yTickSize = width - margin.left - margin.right;
  let yAxis = g => g
    .attr("transform", `translate(${width - margin.right},0)`)
    .call(d3.axisRight(y).tickSize(-yTickSize).tickSizeOuter(-yTickSize))
    .call(g => g.select(".domain").remove())
    .call(g => g.select(".tick:last-of-type text").clone()
      .attr("x", 3)
      .attr("text-anchor", "start")
      .attr("font-weight", "bold")
      .text(data.y));

  chart.append("g").call(xAxis);
  chart.append("g").call(yAxis);

  var tooltip = chart
    .append("text")
    .attr("x", margin.left * 2)
    .attr("y", margin.top + 20)
    .style("font-size", 15)
    .text(title);

  if (stacked) {
    let cls = 'area-' + titleSlug;
    let area = d3.area()
      .x(d => x(d.data.date))
      .y0(d => y(d[0]))
      .y1(d => y(d[1]));

    chart.append("g")
      .selectAll("path")
      .data(series)
      .join("path")
        .attr("class", cls)
        .attr("fill", ({key}) => color(key))
        .attr("stroke-width", 1)
        .attr("stroke", "none")
        .attr("d", area)
        .on("mousemove", function(d, i) {
          let last = d[d.length - 1];
          let lastValue = last[1] - last[0];
          tooltip.text(title + ': ' + d.key + ': ' + lastValue);
        })
        .on("mouseover", function(d) {
          d3.selectAll("." + cls).style("opacity", .2);
          d3.select(this).style("opacity", 1).style("stroke", "black");
        })
        .on("mouseleave", function(d) {
          d3.selectAll("." + cls).style("opacity", 1).style("stroke", "none");
        })
      .append("title")
        .text(({key}) => key);
  } else {
    let line = d3.line()
      .x(d => x(d.d))
      .y(d => y(d.v));

    chart.append("g")
      .selectAll("path")
      .data(series)
      .join("path")
        .attr("fill", "none")
        .attr("stroke-width", 2)
        .attr("stroke", ({key}) => color(key))
        .attr("d", line)
      .append("title")
        .text(({key}) => key);
  }

  return chart.node();
}

function makeKey(regions, excluded) {
  let key = d3.create("div").classed("regions", true);

  key.append("span").text("Regions: ");

  key.append("span")
    .text(excluded.length > 10 ? "All" : "None")
    .classed("swatch", true)
    .style("background-color", excluded.length > 10 ? "white" : "grey")
    .on("click", function () {
      let swatch = d3.select(this);
      let active = swatch.style("background-color") == "grey";
      excluded.splice(0, excluded.length);
      if (active) {
        regions.map(r => {excluded.push(r);});
      }
      updateGraph();
    });
  key.append("span").text(" ");

  regions.map(region => {
    key.append("span")
      .text(region)
      .classed("swatch", true)
      .style("background-color", excluded.includes(region) ? "white"
                                                           : color(region))
      .on("click", function () {
        let swatch = d3.select(this);
        let active = !excluded.includes(region);
        if (active) {
          excluded.push(region);
        } else {
          excluded.splice(excluded.indexOf(region), 1);
        }
        updateGraph();
      });
    key.append("span").text(" ");
  });

  return key.node();
}

function chartOptions(name, options, current) {
  let ts = d3.create("div").classed("chart-options", true);

  ts.append("span").text(name + ": ");

  for (let o in options) {
    let isOn = current.includes(o);
    ts.append("span")
      .text(o)
      .classed("swatch", true)
      .style("background-color", isOn ? "#ccccff" : "white")
      .on("click", function () {
        let swatch = d3.select(this);
        current[0] = o;
        updateGraph();
      });
    ts.append("span").text(" ");
  }

  return ts.node();
}

let regions = allData.regions;
let excludedRegions = [];
let period = ["All"];
let smoothing = ["0"];
let stacked = ["no"];
let series = ["New cases"];

let colorScheme = [];
for (let i = 0; i < regions.length; i++) {
  colorScheme.push(d3.interpolateSinebow(i / regions.length));
}
let color = d3.scaleOrdinal().domain(regions).range(colorScheme);

function updateGraph() {
  d3.select("#options").html("");
  d3.select("#cases").html("");

  d3.select("#options").append(() => makeKey(regions, excludedRegions));
  d3.select("#options").append(() => chartOptions("Series", seriesOptions, series));
  d3.select("#options").append(() => chartOptions("Period", periods, period));
  d3.select("#options").append(() => chartOptions("Smoothing", smoothingLevels, smoothing));
  d3.select("#options").append(() => chartOptions("Stacked", yesNo, stacked));

  let data = seriesOptions[series[0]];
  let c_data = prepareData(data, regions, excludedRegions, period, smoothing);
  d3.select("#cases").append(() => makeChart(c_data, {
    stacked: yesNo[stacked[0]],
    title: series[0],
  }));

  let data_d = applyTransform(rateTransform, data)
  let c_data_d = prepareData(data_d, regions, excludedRegions, period, smoothing);
  d3.select("#cases").append(() => makeChart(c_data_d, {
    stacked: yesNo[stacked[0]],
    height: 400,
    title: series[0] + " per day"
  }));

  let data_dd = applyTransform(rateTransform, data_d)
  let c_data_dd = prepareData(data_dd, regions, excludedRegions, period, smoothing);
  d3.select("#cases").append(() => makeChart(c_data_dd, {
    height: 400,
    stacked: false,
    title: series[0] + " per day change"
  }));

  if (series[0] == "New cases") {
    let impliedR = applyTransform(impliedRTransform, data_d)
    let c_impliedR = prepareData(impliedR, regions, excludedRegions, period, smoothing);

    d3.select("#cases").append(() => makeChart(c_impliedR, {
      height: 400,
      maxValue: 5,
      stacked: false,
      title: "Implied R"
    }));
  }
}

updateGraph();
    </script>
  </body>
</html>
